#!/bin/bash

# Author: Nathanel Titane - nathanel.titane@gmail.com - Copyright 2014

shopt -s extglob globstar nullglob

# model modify #

black= red= green= yellow= blue= magenta= cyan= white= reset=

if [[ -t 1 ]]
then
	black=$(tput setaf 0)
	red=$(tput setaf 1)
	green=$(tput setaf 2)
	yellow=$(tput setaf 3)
	blue=$(tput setaf 4)
	magenta=$(tput setaf 5)
	cyan=$(tput setaf 6)
	white=$(tput setaf 7)
	reset=$(tput sgr0)
fi

version="21-05-2016"
script=$(basename -- "$0")

while (($#))
do
	case "$1" in
		-l|--ldr)
			extension_filter="ldr"
			;;
		-m|--mpd)
			extension_filter="mpd"
			;;
		-c|--color)
			option="color"
			;;
		-p|--part)
			option="part"
			;;
		-b|--bind)
			option="bind"
			;;
		-f|--force)
			force_write="force"
			;;
		-h|--help)
			echo -e "Usage:"
			echo -e "./$script [EXTENSION] [OPTION]"
			echo -e ""
			echo -e "Utility options:"
			echo -e "-l, --ldr \t\t Selects ldr file format as target."
			echo -e "-m, --mpd \t\t Selects mpd file format as target. - This option has not yet been implemented."
			echo -e "-c, --color \t\t Modifies the part color attribute only."
			echo -e "-p, --part \t\t Modifies the part number attribute only."
			echo -e "-b, --bind \t\t Matches a part to a specific color and modifies the color for that part."
			echo -e "-f, --force \t\t Assumes 'Yes' and forces the overwrite of the original model file after modification."
			echo -e "-h, --help \t\t Show help options."
			echo -e "-v, --version \t Print version."
			exit
			;;
		-v|--version)
			echo -e "$script $version"
			exit
			;;
		*)
			echo -e "$script: Unknown option $1"
			echo -e "Try '$script --help' for options information."
			exit
			;;
		esac
	shift
done

if [[ "$extension_filter" == "ldr" ]]
then
	extension_filter="ldr"
	extension="ldr"

elif [[ "$extension_filter" == "mpd" ]]
then
	extension_filter="mpd"
	extension="mpd"
else
	extension_filter="mpd"
	extension="mpd"

	echo "${yellow}Defaulting to mpd file format option.${reset}" #  Warning when no option set for file type
	echo ""
fi

parse_input () {
	while true
	do
		read input

		if [[ -z $input ]]
		then
			echo "${yellow}Warning: Empty value. Please try again...${reset}"
		else
			break
		fi
	done
}


parse_colors () {
	colors="/media/Disk/Dropbox/Linux/scripts/ldraw/colors" # LDraw color definitions

	parse_input

	color_input="${input,,}"

	while IFS=$'\t'
	read -r ldraw_color_name ldraw_color_number ldraw_color_hex_value
	do
		# Color input entries cleanup

		# Color name
		space_name="${ldraw_color_name//_/ }"		# Remove underscores from name
		name="${space_name,,}"				# Set name to lowercase for input match
		ldraw_color_name="${name}"			# Reattribute input variable to lowercase name value

		# Color hex value

		hex_value="${ldraw_color_hex_value//#/}"	# Remove pound from name
		hex_value="${hex_value,,}"			# Set name to lowercase for input match
		ldraw_color_hex_value=${hex_value}		# Reattribute input variable to lowercase name value

		if [[ "$color_input" == "$ldraw_color_name" || "$color_input" == "$ldraw_color_number" || "$color_input" == "$ldraw_color_hex_value" ]]
		then
			echo "Color name................: ${ldraw_color_name}" 		# Confirmation
			echo "Color number..............: ${ldraw_color_number}"	# Confirmation
			echo "Color hexadecimal value...: ${ldraw_color_hex_value}"	# Confirmation

			return "$ldraw_color_number"
		fi

	done < "$colors"

	echo "${red}NO MATCH${reset}"
	exit 1
}

parse_parts () {
	parse_input
	part_input="$input"
	return "$part_input"
}

# Confirm options being used before processing

echo "${cyan}Utility started using the $extension file format option.${reset}"
echo "${cyan}Utility started using the $option modification option.${reset}"
echo ""

directory=$(zenity --file-selection  --multiple --directory --separator=$'\n' --title="Select a Directory") 2> /dev/null || exit # Specify directory location or exit on 'Cancel'

cd "$directory" || exit

if [[ "$option" = "color" ]]
then
	echo "${cyan}Please enter the color description [ name / number / hexadecimal ] you would like to modify.${reset}"
	parse_colors
	old_color="$?"

	echo "${cyan}Please enter the color description [ name / number / hexadecimal ] you would like to set.${reset}"
	parse_colors
	new_color="$?"
fi

if [[ "$option" = "part" ]]
then
	echo "${cyan}Please enter the part number you would like to modify.${reset}"
	parse_parts
	old_part="$?"

	echo "${cyan}Please enter the part number you would like to set.${reset}"
	parse_parts
	new_part="$?"
fi

if [[ "$option" = "bind" ]]
then
	echo "${cyan}Please enter the part number you would like to modify.${reset}"
	parse_parts
	part_selection="$?"

	echo "${cyan}Please enter the matching color description [ name | number | hexadecimal ] you would like to modify for the selected part.${reset}"
	parse_colors
	old_color="$?"

	echo "${cyan}Please enter the new color description [ name | number | hexadecimal ] you would like to set for the selected part.${reset}"
	parse_colors
	new_color="$?"
fi

# Substitution

for model in "${directory%/}"/**/*."$extension_filter"
do
	model_export="${model##*/}"
	model_export_name="${model_export%.*}"
	model_export_name_clean="${model_export_name:5}"

	line_number=0 # Initial line count

	while IFS=
	read -r line
	do
		temporary_file="$model.tmp"
		stamp=$(date +"%m-%d-%Y-%H-%M-%S")

		line_number=$(( $line_number + 1 ))

		if [[ "$line" == *!LEOCAD* ]] || [[ "$line" == *FILE* ]] || [[ "$line" == *NOFILE* ]]
		then
			echo "$line" >> "$temporary_file" # Skip header and footer lines containing matching patterns - prevents model file syntax modification
			continue
		else
			IFS=' '
			read -r flag color x y z a b c d e f g h i part_dat <<< "$line"

			vect_x="$a $b $c"
			vect_y="$d $e $f"
			vect_z="$g $h $i"

			# ⎡ a d g 0 ⎤	⎡ a b c x ⎤
			# ⎢ b e h 0 ⎥	⎢ d e f y ⎥
			# ⎢ c f i 0 ⎥	⎢ g h i z ⎥
			# ⎣ x y z 1 ⎦	⎣ 0 0 0 1 ⎦

			IFS='.'
			read part suffix <<< "$part_dat" # Split part argument into part number and part extension

			if [[ "$option" = "color" ]]
			then
				color="$new_color"

				echo "${red}Changing..:${reset} $old_color"
				echo "${red}Setting...:${reset} $new_color"
				echo ""
			fi


			if [[ "$option" = "part" ]]
			then
				part="$new_part"

				echo "${red}Changing..:${reset} $old_part"
				echo "${red}Setting...:${reset} $new_part"
				echo ""
			fi

			if [[ "$option" = "bind" ]]
			then
				if [[ "$part" == "$part_selection" ]]
				then
					if [[ "$color" = "$old_color" ]]
					then
						color="$new_color"
					fi
				fi
			fi

			# Write changes to tempporary file

			echo "$flag" "$color" "$x" "$y" "$z" "$a" "$b" "$c" "$d" "$e" "$f" "$g" "$h" "$i" "$part.$suffix" >> "$temporary_file"
		fi

	done < "$model" # Feed model input for parsing into loop

	if [[ "$force_write" = "force" ]]
	then
		reply="yes"
		echo "${red}'Force write' option enabled - writing chages to original model file!${reset}"
	else
		echo "${cyan}Would you like to write your changes to the original model file ($model)? [ Yes | No ]${reset}"

		read reply
	fi

	if [[ "$reply" = [yY] || "$reply" = [yY][eE][sS] ]]
	then
		echo "${yellow}Writing file ($model)...${reset}"

		mv "$temporary_file" "$model"
	else
		echo "${yellow}Unknown input - Writing changes to model file copy...${reset}"

		mv "$temporary_file" "$stamp_${model_export_name%.tmp}.$extension"
	fi
done

echo "${cyan}Done.${reset}"
echo ""
